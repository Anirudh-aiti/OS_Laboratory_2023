# https://collabedit.com/fe8g5
Group - 12 : 
    Syam Manoj Kumar Paila (20CS10041)
    Anirudh Aitipamula (20CS30002)
    Ganjikunta Vijay Kumar (20CS30018)
    Vineet Amol Pippal (20CS30058)
    
-actionQueue, userQueue

Data Structures:-

- struct action
    - user_id 
        - id of the user who performed the action
        
    - action_id 
        - id of the action (either a post or a like or a comment)
        - each action of a particular user has a particular action_id associa
        
    - action_type  
        - 0 for post, 1 for like, 2 for comment
        
    - priority_val 
        - priority value of the action
        
    - timestamp
        - time when the action is performed


- struct feed_compare
    - this is a functor (a class with an overloaded 'operator()') used later to sort queues according to their priorities


- class node
    - int user_id
        - id of the user (initialization step has input id given)
        
    - bool order
        - 0 represents priority based on # of common friends, 1 represents priority based on chronological order
        - order = rand() % 2 (initialization step gives order randomly)
        
    - queue <action> wallQueue
        - wall queue of each node is implemented as a normal queue data structure.
        - Queue containing actions of this user
        
    - priority_queue <action, vector<action>, feed_compare> feedQueue
        - feed queue of each node is implemented as a priority queue (internally as a vector) with comparision operator defined as feed_compare (common friends based or chronological based)    
        - Queue containing neighbour's actions (which come up on the feed of this user)

    - vector<int> numActions
        - 3 vectors of integers having the count of number of actions of each type
            - numActions[0] - post count
            - numActions[1] - like count
            - numActions[2] - comment count


- map <int, vector<int>> graph
    - we store the entire graph in this data structure
    - it is a map of type <node_id, all_nodes_neighbouring_to_node_id (adjacency_list)> 
    * using this type of data structure for graph makes it easy for a user_id to obtain list of neighbours and no.of neighbours


- map <int, node*> user
    - this stores the <user_id, pointer to the node containing other details of user_id>
    - note that this does not contain the list of neighbouring nodes of the user_id, to obtain the list of neighbouring nodes, we need to use the above graph


- queue <action> actionQueue
    - queue of actions (shared between userSimulator and pushUpdate)
    - large queue containing the list of all actions generated by all users (by the userSimulator)


- queue <int> userQueue
    - queue of users whose feed queue get upadated (shared between pushUpdate and readPost)
    
