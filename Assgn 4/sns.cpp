#include <bits/stdc++.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <fstream>
#include <ostream>
#include <errno.h>
#include <chrono>
using namespace std;
using namespace std::chrono;

//----- MACROS -----//
#define NUM_PUSH_UPDATE 1
#define NUM_READ_POST 1
#define BUFF_SIZE 300
#define NUM_NODES 40000

//---- Structs and Classes ----//
typedef struct action
{
    int user_id = 0; // user who performed the action
    int action_id = 0; // id of the post, like or comment
    int action_type = 0; // 0 for post, 1 for like, 2 for comment
    long priority_val = 0; // priority value of the action
    time_t timestamp; // time of the action
}action;

// custom comparators for feedQueue
// compare the priority values of two actions
struct feed_compare
{
    // sort in descending order of priority
    bool operator() (const action &a, const action &b) const
    {
        return a.priority_val < b.priority_val;
    }
};

class node 
{
    public:
        int user_id = 0; // id of the user
        bool order = -1; // 0 for priority, 1 for chronological
        queue <action> wallQueue; // actions generated by the user
        priority_queue <action, vector<action>, feed_compare> feedQueue; // actions generated by the user's friends (neighbors)
        vector <int> numActions = {0, 0, 0}; // number of actions of each type
    
    node(int id) { 
        user_id = id; 
        order = rand() % 2; // random order
        wallQueue = queue <action> ();
        feedQueue = priority_queue <action, vector<action>, feed_compare> ();
    }
};

//----- Helper Functions -----//

// Print a string to a file using fwrite in given mode
// (to print to stdout, use "stdout" as the file name)
void fileWrite(string file, string str, string mode)
{
    if (file == "stdout") {
        char * buff = new char[str.length() + 1];
        strcpy(buff, str.c_str());
        fwrite(buff, sizeof(char), str.length(), stdout);
        free(buff);
    }
    else {
        FILE * fp = fopen(file.c_str(), mode.c_str());
        char * buff = new char[str.length() + 1];
        strcpy(buff, str.c_str());
        fwrite(buff, sizeof(char), str.length(), fp);
        fclose(fp);
        free(buff);
    }
}

//----- Global Variables -----//
map <int, vector<int>> graph; // graph of users
map <int, node* > user; // map of users

queue <action> actionQueue; // queue of actions (shared between userSimulator and pushUpdate)
queue <int> userQueue; // queue of users (shared between pushUpdate and readPost)

string actionName[3] = {"post" , "like", "comment"};

//----- Graph Functions ----//
void print_graph(string filename)
{
    ofstream out(filename);
    for (auto it = graph.begin(); it != graph.end(); it++)
    {
        out << it->first << " : ";
        for (auto it2 = it->second.begin(); it2 != it->second.end(); it2++) (it2 != it->second.end() - 1)? out << *it2 << ", " : out << *it2 << " ";
        out << endl;
    }
    out.close();
}

void print_nodes(string filename)
{
    ofstream out(filename);
    for (auto it = user.begin(); it != user.end(); it++)
    {
        out << it->first << " : ";
        out << "order: " << it->second->order << endl;
    }
    out.close();
}

//----- LOCK Functions, CONDS and MUTEXES -----//
// (wrappers for pthread_mutex_lock and pthread_mutex_unlock)
// mutex for actionQueue
pthread_mutex_t actionQueue_mutex;
pthread_cond_t actionQueue_cond;
bool AQ_isEmpty = true;

pthread_mutex_t feedQueue_mutex[NUM_NODES];
pthread_cond_t feedQueue_cond[NUM_NODES];

pthread_mutex_t userQueue_mutex;
pthread_cond_t userQueue_cond;
bool UQ_isEmpty = true;

void lock(pthread_mutex_t * lock)
{
    int ret = pthread_mutex_lock(lock);
    if (ret != 0) 
    {
        // print in red
        cout << "\033[1;31m";            // read action
            char * buff = new char[BUFF_SIZE];

        cout << "Error: lock failed!" << endl;
        cout << "\033[0m";
        exit(1);
    }
}
void unlock(pthread_mutex_t * lock)
{
    int ret = pthread_mutex_unlock(lock);
    if (ret != 0) cout << "Error: unlock failed!" << endl;
}

//----- Thread Functions -----//
/*
    userSimulator Thread:
*/
void * userSimulator(void * vars)
{
    while (true)
    {
        fileWrite("stdout", ">> userSimulator Thread awoke\n", "a");
        fileWrite("sns.log", ">> userSimulator Thread awoke\n", "a");

        // choose 100 random nodes
        set <int> chosen;
        while (chosen.size() < 100)
        {
            int x = rand() % graph.size();
            chosen.insert(x);
        }

        // generate actions
        for (auto it = chosen.begin(); it != chosen.end(); it++)
        {
            int n = log2(graph[*it].size() * 2.0) * 3.0;
            char * buff = new char[BUFF_SIZE];
            sprintf(buff, "\tuserSimulator :: chosen <%d> {degree: %ld , actions: %d}\n", *it, graph[*it].size(), n);
            // fileWrite("stdout", buff, "a");
            fileWrite("sns.log", buff, "a");
            free(buff);

            for (int i = 0; i < n; i++)
            {
                int action_type = rand() % 3;
                user[*it]->numActions[action_type]++;
                int user_priority = user[*it]->order;
                int user_degree = graph[*it].size();

                // print action
                char * buff = new char[BUFF_SIZE];
                sprintf(buff, "\t\tuserSimulator :: <%d> : %d (%s)\n", *it, action_type, actionName[action_type].c_str());
                // fileWrite("stdout", buff, "a");
                fileWrite("sns.log", buff, "a");
                free(buff);
                
                // push action to wallQueue
                user[*it]->wallQueue.push(action{.user_id = *it, .action_id = i, .action_type = action_type, .priority_val = (user_priority == 0)? user_degree : time(NULL), .timestamp = time(NULL)});

                // push action to actionQueue
                //--- START CRITICAL SECTION
                lock(&actionQueue_mutex);

                actionQueue.push(action{.user_id = *it, .action_id = i, .action_type = action_type, .priority_val = (user_priority == 0)? user_degree : time(NULL), .timestamp = time(NULL)});

                pthread_cond_signal(&actionQueue_cond);
                AQ_isEmpty = false;
                
                unlock(&actionQueue_mutex);
                //--- END CRITICAL SECTION
            }
        }

        sleep(120);
    }
    pthread_exit(NULL);
}

/*
    pushUpdate Thread: 
*/
void * pushUpdate(void * vars)
{
    sleep(1);
    char * buff = new char[BUFF_SIZE];
    sprintf(buff, ">> pushUpdate Thread awoke\n" );
    fileWrite("stdout", buff, "a");
    fileWrite("sns.log", buff, "a");
    free(buff);

    while (1)
    {
        //--- START CRITICAL SECTION
        lock(&actionQueue_mutex);

        while (AQ_isEmpty) pthread_cond_wait(&actionQueue_cond, &actionQueue_mutex);

        static action a = actionQueue.front();
        actionQueue.pop();
        if (actionQueue.empty()) AQ_isEmpty = true;
        
        unlock(&actionQueue_mutex);
        //--- END CRITICAL SECTION

        char * buff = new char[BUFF_SIZE];
        sprintf(buff, "\tpushUpdate :: popped action -> {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld}\n", a.user_id, a.action_id, a.action_type, a.timestamp);
        // fileWrite("stdout", buff, "a");
        fileWrite("sns.log", buff, "a");

        set <int> userSet; // set of users to be notified

        // push action to neighbors
        for (auto it = graph[a.user_id].begin(); it != graph[a.user_id].end(); it++)
        {
            //--- START CRITICAL SECTION
            lock(&feedQueue_mutex[*it]);

            user[*it]->feedQueue.push(a);
            pthread_cond_signal(&feedQueue_cond[*it]);

            // print action
            char * buff = new char[BUFF_SIZE];
            sprintf(buff, "\t\tpushUpdate :: pushed action <%d> <- {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld}\n", (int)*it, a.user_id, a.action_id, a.action_type, a.timestamp);
            // fileWrite("stdout", buff, "a");
            fileWrite("sns.log", buff, "a");
            free(buff);

            unlock(&feedQueue_mutex[*it]);
            //--- END CRITICAL SECTION


            //--- START CRITICAL SECTION
            lock(&userQueue_mutex);

            if (userSet.find(*it) == userSet.end())
            {
                userQueue.push(*it);
                userSet.insert(*it);
            }
            
            UQ_isEmpty = false;
            pthread_cond_signal(&userQueue_cond);

            unlock(&userQueue_mutex);
            //--- END CRITICAL SECTION
        }
    }

    pthread_exit(0);
}

/*
    readPost Thread:
*/
void * readPost(void * vars)
{
    sleep(1);
    char * buff = new char[BUFF_SIZE];
    sprintf(buff, ">> readPost Thread awoke\n" );
    fileWrite("stdout", buff, "a");
    fileWrite("sns.log", buff, "a");
    free(buff);
    
    while (1)
    {
        //---- START CRITICAL SECTION
        lock(&userQueue_mutex);

        while (UQ_isEmpty) pthread_cond_wait(&userQueue_cond, &userQueue_mutex);

        int user_id = userQueue.front();
        userQueue.pop();
        if (userQueue.empty()) UQ_isEmpty = true;

        unlock(&userQueue_mutex);
        //---- END CRITICAL SECTION

        //--- START CRITICAL SECTION
        lock(&feedQueue_mutex[user_id]);

        while (user[user_id]->feedQueue.empty()) pthread_cond_wait(&feedQueue_cond[user_id], &feedQueue_mutex[user_id]);

        action a = user[user_id]->feedQueue.top();
        user[user_id]->feedQueue.pop();

        char * buff = new char[BUFF_SIZE];
        sprintf(buff, "\treadPost :: popped feed <%d> -> {UserID: %d , ActionID: %d, Action: %d , Timestamp: %ld}\n", user_id, a.user_id, a.action_id, a.action_type, a.timestamp);
        // fileWrite("stdout", buff, "a");
        fileWrite("sns.log", buff, "a");
        free(buff);

        unlock(&feedQueue_mutex[user_id]);
        //--- END CRITICAL SECTION
    }

    pthread_exit(0);
}

/*
    Main Thread:
*/
signed main()
{   
    // mutex and cond inits
    pthread_mutex_init(&actionQueue_mutex, NULL);
    pthread_cond_init(&actionQueue_cond, NULL);
    for (int i = 0; i < NUM_NODES; ++i) 
    {
        pthread_mutex_init(&feedQueue_mutex[i], NULL);
        pthread_cond_init(&feedQueue_cond[i], NULL);
    }
    pthread_mutex_init(&userQueue_mutex, NULL);
    pthread_cond_init(&userQueue_cond, NULL);

    // other inits and file writes
    setvbuf(stdout, NULL, _IONBF, 0);
    srand(time(NULL));
    fileWrite("sns.log", ">> Main Thread awoke\n", "w");  
    fileWrite("stdout", ">> Main Thread awoke\n", "w");

    // load graph
    ifstream file("musae_git_edges.csv");
    string line;

    // skip first line
    getline(file, line);
    while (getline(file, line))
    {
        // read line a and b from "a,b"
        int i = line.find(',');
        int x = stoi(line.substr(0, i));
        int y = stoi(line.substr(i + 1, line.length() - i - 1));

        // if x or y have not been encountered before, add them to the user map
        static node X(x), Y(y);
        if (user.find(x) == user.end()) user[x] = &X;
        if (user.find(y) == user.end()) user[y] = &Y;

        graph[x].push_back(y);
        graph[y].push_back(x);
    }

    // optional print graph and nodes
    // print_graph("graph.txt");
    // print_nodes("nodes.txt");

    // create threads
    pthread_t userSimulator_t, pushUpdate_t[NUM_PUSH_UPDATE], readPost_t[NUM_READ_POST];
    pthread_create(&userSimulator_t, NULL, userSimulator, NULL);
    for (int i = 0; i < NUM_PUSH_UPDATE; i++) pthread_create(&pushUpdate_t[i], NULL, pushUpdate, NULL);
    for (int i = 0; i < NUM_READ_POST; i++) pthread_create(&readPost_t[i], NULL, readPost, NULL);

    // wait for threads
    pthread_join(userSimulator_t, NULL);
    for (int i = 0; i < NUM_PUSH_UPDATE; i++) pthread_join(pushUpdate_t[i], NULL);
    for (int i = 0; i < NUM_READ_POST; i++) pthread_join(readPost_t[i], NULL);

    // mutex and cond destroy
    pthread_mutex_destroy(&actionQueue_mutex);
    pthread_cond_destroy(&actionQueue_cond);
    for (int i = 0; i < 40000; ++i) 
    {
        pthread_mutex_destroy(&feedQueue_mutex[i]);
        pthread_cond_destroy(&feedQueue_cond[i]);
    }
    pthread_mutex_destroy(&userQueue_mutex);
    pthread_cond_destroy(&userQueue_cond);

    return 0;
}