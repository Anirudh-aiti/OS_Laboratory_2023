#include <bits/stdc++.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <fstream>
#include <ostream>
using namespace std;

//---- Structs and Classes ----//
typedef struct action
{
    int user_id = 0; // user who performed the action
    int action_id = 0; // id of the post, like or comment
    int action_type = 0; // 0 for post, 1 for like, 2 for comment
    time_t timestamp; // time of the action
}action;

class node 
{
    public:
        int user_id = 0; // id of the user
        bool order = -1; // 0 for priority, 1 for chronological
        queue <action> wallQueue; // actions generated by the user
        queue <action> feedQueue; // actions generated by the user's friends (neighbors)
    
    node(int id) { 
        user_id = id; 
        order = rand() % 2;
        wallQueue = queue <action> ();
        feedQueue = queue <action> ();
    }
};

//----- Global Variables -----//
map <int, vector<int>> graph; // graph of users
map <int, node* > user; // map of users

//----- Graph Functions ----//
void print_graph(string filename)
{
    ofstream out(filename);
    for (auto it = graph.begin(); it != graph.end(); it++)
    {
        out << it->first << " : ";
        for (auto it2 = it->second.begin(); it2 != it->second.end(); it2++) (it2 != it->second.end() - 1)? out << *it2 << ", " : out << *it2 << " ";
        out << endl;
    }
    out.close();
}

void print_nodes(string filename)
{
    ofstream out(filename);
    for (auto it = user.begin(); it != user.end(); it++)
    {
        out << it->first << " : ";
        out << "order: " << it->second->order << endl;
    }
    out.close();
}


//----- Thread Functions -----//
/*
    userSimulator Thread:
        It will choose 100 random nodes from the graph. hen for each node, generate n actions, n needs to be
        proportional to the log2 (degree of the node), since more popular nodes will do
        more actions. For each action, action_type will be chosen randomly from the fixed
        list of three actions (post, comment, like).
*/
void * useSimulator(void * vars)
{
    while (true)
    {
        sleep(1);
        // open "sns.log"
        ofstream out("sns.log", ios::app);
        out << ">> userSimulator Thread awoke" << endl;

        // choose 100 random nodes
        set <int> chosen;
        while (chosen.size() < 100)
        {
            int x = rand() % graph.size();
            chosen.insert(x);
        }

        // print chosen nodes
        out << "\tChosen Nodes: ";
        for (auto it = chosen.begin(); it != chosen.end(); it++) out << *it << " ";
        out << endl;
        cout << "\tChosen Nodes: ";
        for (auto it = chosen.begin(); it != chosen.end(); it++) cout << *it << " ";
        cout << endl;

        // generate actions
        for (auto it = chosen.begin(); it != chosen.end(); it++)
        {
            int n = log2(graph[*it].size() * 2) * 3.0;
            out << "\t" << "<" << *it << ">" << " degree: " << graph[*it].size() << " : " << n << " actions" << endl;
            cout << "\t" << "<" << *it << ">" << " degree: " << graph[*it].size() << " : " << n << " actions" << endl;
            for (int i = 0; i < n; i++)
            {
                int action_type = rand() % 3;
                out << "\t\t" << *it << " : " << action_type << endl;
                cout << "\t\t" << *it << " : " << action_type << endl;

                // push action to wallQueue
                user[*it]->wallQueue.push(action{.user_id = *it, .action_id = i, .action_type = action_type, .timestamp = time(NULL)});
            }
        }

        sleep(120);
        out.close();
    }
    pthread_exit(NULL);
}

/*
    pushUpdate Thread:
*/
void * pushUpdate(void * vars)
{
    sleep(1);
    cout << "pushUpdate Thread" << endl;
    return NULL;
}

/*
    readPost Thread:
*/
void * readPost(void * vars)
{
    sleep(1);
    cout << "readPost Thread" << endl;
    return NULL;
}

/*
    Main Thread:
        The main thread loads a static graph stored in "musae_git_edges.csv" into memory.
        Then the main thread will create a userSimulator thread,a pool of 10 readPost
        threads and another pool of 25 pushUpdate threads and wait for the threads.
*/
signed main()
{
    srand(time(NULL));
    ofstream out("sns.log");
    out << ">> Main Thread awoke" << endl;
    out.close();

    // load graph
    ifstream file("musae_git_edges.csv");
    string line;

    // skip first line
    getline(file, line);
    while (getline(file, line))
    {
        // read line a and b from "a,b"
        int i = line.find(',');
        int x = stoi(line.substr(0, i));
        int y = stoi(line.substr(i + 1, line.length() - i - 1));

        // if x or y have not been encountered before, add them to the user map
        static node X(x), Y(y);
        if (user.find(x) == user.end()) user[x] = &X;
        if (user.find(y) == user.end()) user[y] = &Y;

        graph[x].push_back(y);
        graph[y].push_back(x);
    }

    print_graph("graph.txt");
    print_nodes("nodes.txt");

    // create threads
    pthread_t userSimulator_t;
    pthread_create(&userSimulator_t, NULL, useSimulator, NULL);

    pthread_t pushUpdate_t[25];
    for (int i = 0; i < 25; i++) pthread_create(&pushUpdate_t[i], NULL, pushUpdate, NULL);

    pthread_t readPost_t[10];
    for (int i = 0; i < 10; i++) pthread_create(&readPost_t[i], NULL, readPost, NULL);

    // wait for threads
    pthread_join(userSimulator_t, NULL);
    for (int i = 0; i < 25; i++) pthread_join(pushUpdate_t[i], NULL);
    for (int i = 0; i < 10; i++) pthread_join(readPost_t[i], NULL);

    return 0;
}